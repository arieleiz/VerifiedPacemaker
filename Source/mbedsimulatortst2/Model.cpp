/*
*  Pacemaker4Mbed (c) 2014 Ariel Eizenberg - arieleiz@seas.upenn.edu.
*  Developed for UPENN CIS 541 course project - verifiable pacemaker.
*
*    This file is part of Pacemaker4Mbed. You can redistribute it and/or modify
*    it under the terms of the Academic Free License 3.0
*	  (http://opensource.org/licenses/AFL-3.0).
*
*/

// THIS FILE WAS AUTO GENERATED BY model2mbed.exe DO NOT MODIFY!!!

#include "Model.h"
using namespace ModelImpl;

namespace Model {
// Channels
SYNCHRONIZATION_CHANNEL_STATE GLOBAL_CHANNEL_VAR_press_STATE; // chan press

const SYNCHRONIZATION_CHANNEL_DATA GLOBAL_CHANNEL_VAR_press_DATA = // chan press
    {
        DBGSTR("chan press[]"),	// name
        false,				// urgent
        false,				// broadcast
        &GLOBAL_CHANNEL_VAR_press_STATE,              // state
    };

SYNCHRONIZATION_CHANNEL GLOBAL_CHANNEL_VAR_press = // chan press
    {
        &GLOBAL_CHANNEL_VAR_press_DATA,         // data
        NULL,              // fired
        NULL,              // context
    };


// ChannelsList
SYNCHRONIZATION_CHANNEL* ALL_CHANNELS[] = 
    {
        &GLOBAL_CHANNEL_VAR_press,
        NULL
    };


SYSTEM_VARIABLES SystemVariables;

// Process - Light

const TRANSITION_ENTRY_DATA Light_TRANS_bright__off__0_DATA =
    {
        DBGSTR("bright__off__0"),	// name
        &Light_STATE_off,				// target
        &GLOBAL_CHANNEL_VAR_press,				// receive
        NULL,				// send
        NULL,               // guard
        NULL,               // update
    };

TRANSITION_ENTRY Light_TRANS_bright__off__0 =
    {
        &Light_TRANS_bright__off__0_DATA,         // data
        NULL,              // transition_pre_execute
        NULL,              // transition_post_execute
        NULL,              // context
    };

static bool guardfunc_Light_TRANS_low__bright__0()
{
    return ((((int)SystemVariables.clk_GLOBAL_y) < (5)));
};
const TRANSITION_ENTRY_DATA Light_TRANS_low__bright__0_DATA =
    {
        DBGSTR("low__bright__0"),	// name
        &Light_STATE_bright,				// target
        &GLOBAL_CHANNEL_VAR_press,				// receive
        NULL,				// send
        guardfunc_Light_TRANS_low__bright__0,               // guard
        NULL,               // update
    };

TRANSITION_ENTRY Light_TRANS_low__bright__0 =
    {
        &Light_TRANS_low__bright__0_DATA,         // data
        NULL,              // transition_pre_execute
        NULL,              // transition_post_execute
        NULL,              // context
    };

static bool guardfunc_Light_TRANS_low__off__0()
{
    return ((((int)SystemVariables.clk_GLOBAL_y) >= (5)));
};
const TRANSITION_ENTRY_DATA Light_TRANS_low__off__0_DATA =
    {
        DBGSTR("low__off__0"),	// name
        &Light_STATE_off,				// target
        &GLOBAL_CHANNEL_VAR_press,				// receive
        NULL,				// send
        guardfunc_Light_TRANS_low__off__0,               // guard
        NULL,               // update
    };

TRANSITION_ENTRY Light_TRANS_low__off__0 =
    {
        &Light_TRANS_low__off__0_DATA,         // data
        NULL,              // transition_pre_execute
        NULL,              // transition_post_execute
        NULL,              // context
    };

static void updatefunc_Light_TRANS_off__low__0()
{
    SystemVariables.clk_GLOBAL_y = (0);
};
const TRANSITION_ENTRY_DATA Light_TRANS_off__low__0_DATA =
    {
        DBGSTR("off__low__0"),	// name
        &Light_STATE_low,				// target
        &GLOBAL_CHANNEL_VAR_press,				// receive
        NULL,				// send
        NULL,               // guard
        updatefunc_Light_TRANS_off__low__0,               // update
    };

TRANSITION_ENTRY Light_TRANS_off__low__0 =
    {
        &Light_TRANS_off__low__0_DATA,         // data
        NULL,              // transition_pre_execute
        NULL,              // transition_post_execute
        NULL,              // context
    };

const TRANSITION_ENTRY* Light_STATE_bright_OUT[] = 
    {
        &Light_TRANS_bright__off__0, // bright__off__0
    NULL
    };

const STATE_ENTRY_DATA Light_STATE_bright_DATA =
    {
        DBGSTR("bright"),	// name
        (TRANSITION_ENTRY* const*)&Light_STATE_bright_OUT,	// target
        StateNormal, // mode
        NULL, // guard
    };

STATE_ENTRY Light_STATE_bright =
    {
        &Light_STATE_bright_DATA,         // data
        NULL,              // state_enter
        NULL,              // state_leave
        NULL,              // context
    };

const TRANSITION_ENTRY* Light_STATE_low_OUT[] = 
    {
        &Light_TRANS_low__bright__0, // low__bright__0
        &Light_TRANS_low__off__0, // low__off__0
    NULL
    };

const STATE_ENTRY_DATA Light_STATE_low_DATA =
    {
        DBGSTR("low"),	// name
        (TRANSITION_ENTRY* const*)&Light_STATE_low_OUT,	// target
        StateNormal, // mode
        NULL, // guard
    };

STATE_ENTRY Light_STATE_low =
    {
        &Light_STATE_low_DATA,         // data
        NULL,              // state_enter
        NULL,              // state_leave
        NULL,              // context
    };

const TRANSITION_ENTRY* Light_STATE_off_OUT[] = 
    {
        &Light_TRANS_off__low__0, // off__low__0
    NULL
    };

const STATE_ENTRY_DATA Light_STATE_off_DATA =
    {
        DBGSTR("off"),	// name
        (TRANSITION_ENTRY* const*)&Light_STATE_off_OUT,	// target
        StateNormal, // mode
        NULL, // guard
    };

STATE_ENTRY Light_STATE_off =
    {
        &Light_STATE_off_DATA,         // data
        NULL,              // state_enter
        NULL,              // state_leave
        NULL,              // context
    };

extern PROCESS_ENTRY_STATE Light_PROCESS_STATE;

PROCESS_ENTRY_THREAD Light_PROCESS_THREAD(&Light_PROCESS_STATE);

const PROCESS_ENTRY_DATA Light_PROCESS_DATA = 
    {
        DBGSTR("Light_PROCESS"),	// name
        &Light_STATE_off, // initState
        &Light_PROCESS_THREAD, // threadptr
    };

PROCESS_ENTRY Light_PROCESS = 
    {
        &Light_PROCESS_DATA,         // data
        NULL,              // process_start
        NULL,              // context
    };

PROCESS_ENTRY_STATE Light_PROCESS_STATE = 
    {
        &Light_PROCESS,         // process
        &Light_PROCESS_THREAD,  // thread
        &Light_PROCESS_DATA,    // data
        NULL,              // current
        NULL,              // next
        false,              // stepped
        false,              // normal_stepped
        ProcessInit,        // state
    };



} // namespace
namespace Model {
volatile PROCESS_ENTRY_STATE* PROCESS_LIST[] =
{
   NULL,
    NULL
};
}

namespace ModelImpl {
volatile PROCESS_ENTRY_STATE** PROCESS_LIST = ::Model::PROCESS_LIST;
int MAX_PROCESS_LIST = 1;
SYNCHRONIZATION_CHANNEL** ALL_CHANNELS = ::Model::ALL_CHANNELS;
}

